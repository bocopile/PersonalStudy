## 들어가기 앞서서
'Effactive Java 3/E' 이라는 책으로 Joshua Bloch 라는 분께서 지으신
책입니다. 백엔드 개발자 4년차로서 이때까지 여러 프로젝트에 사용되었던 언어입니다.
그러나 문득 내가 JAVA에 대해서 얼마나 알고, 자신있게 다른 사람들 한테 내가 아는 지식을 
전파할수 있을까라는 고민을 해본 결과 이쯤에서 java를 한번 깊게 되집어 포는 시간을 가져야 할거 같았습니다.
해당 책의 목차 가 이끌렸고 이번에 이 책으로 되돌아보는 시간을 가지고자 합니다.

## 2장 객체 생성과 파괴

### 아이템 1. 생성자 대신에 정적 팩토리 메소드를 고려해라

### 아이템 2. 생성자에 매개 변수가 많다면 빌더를 고려해라.

### 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증해라

### 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용해라

### 아이템 5. 자원을 작접 명시하지 말고 의존 객체 주입을 사용해라

### 아이템 6. 불필요한 객체 생성을 피해라

### 아이템 7. 다 쓴 객체 참조를 해제해라

### 아이템 8. finalizer와 cleaner사용을 피해라

### 아이템 9. try-finally 보다는 try-with-resource를 사용해라

## 3장 모든 객체의 공통 메소드

### 아이템 10. equals는 일반 규칙을 지켜 재정의해라

### 아이템 11. equals를 재정의하려거든 hashCide도 재정의해라

### 아이템 12. toString을 항상 재정의해라

### 아이템 13. clone 재정의는 주의해서 진행해라

### 아이템 14. comparable을 구현할지 고려해라

## 4장 클래스와 인터페이스

### 아이템 15. 클래스와 맴버의 접근 권한을 최소화해라

### 아이템 16. public 클래스에는 public 필드가 아닌 접근자 메서드를 사용해라

### 아이템 17. 변경 가능성을 최소화해라

### 아이템 18. 상속보다는 컴포지션을 사용해라

### 아이템 19. 상속을 고려해 설계하고 문서화 해라. 그렇지 않다면 상속을 금지하자

### 아이템 20. 추상 클래스보다는 인터페이스를 우선순위에 두자

### 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라
Java 8 이전에는 기존 구현체를 깨트리지 않고는 인터페이스에 메소드를 추가할 방법이 없었다.
Java 8이 등장하면서 기존 인터페이스에 메소드를 추가할 수 있도록 디폴트 메소드가 등장하였지만 위험이 완전하게 없어지진 않았따.

-> 즉 디폴트 메소드는 컴파일이 성공하더라도 기존 구현체에 런타임 오류를 일으킬수 있다.

-> 인터페이스를 설계할 떄는 여전히 세심한 주의를 기울여야 한다.


### 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용해라
인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.

-> 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것이다.

-> 맞지 않는 예) 상수 인터페이스 안티 패턴

-> 상수를 공개 할 목적이라면 여러가지 선택지가 있다.

- 특정클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야 한다.

  -> ex) 모든 숫자 기본 타입의 박싱 클래스(Integer,Double의 MIN_VALUE / MAX_VALUE)

- 열거 타입으로 나타내기 적합한 상수라면 열거타입으로 만든 후에 공개한다 (아이템 34)

- 그것도 아니라면, 인스턴스화 할수 없는 유틸리티 클래스(아이템 4)에 담아 공개


#### 정리 : 인터페이스는 타입을 정의하는 용도로만 사용하고 , 상수 공개용 수단으로 사용하지 말자

### 아이템 23. 테그 달린 클래스 보다는 클래스 계층 구조를 활용해라

테그 달린 클래스에는 단점이 많다.

- 열거 타인 선언, 테그 필드, switch문 등 쓸데 없는 코드가 많다.

- 다른 의미를 위한 코드도 언제나 같이 따라다녀 메모리도 많이 사용한다.

- 또 다른 의미를 추가하려면 코드를 수정해야 한다.

- 인스턴스 타입만으로는 현재 나타내는 의미를 알길이 전혀 없다.

 -> 결론 : 테그 달린 클래스는 장황하고 오류가 많으며 비효율적이다.
 
 #### 정리 : 테그 달린 클래스를 써야 하는 상황이 거의 없다. 새로운 클래스를 작서하는데 테그 필드가 등장한다면 테그를 없애고 계층 구조로 대체하는 방법을 살표보자
 
 ### 아이템 24. 멤버 클래스는 되도록 static으로 만들라
 
 중첩 클래스에는 네 가지가 있으며, 가각의 쓰임이 다르다. 메소드 밖에서도 사용해야 하거나
 메소드 안에서 정의하기엔 너무 길다면 맴버 클래스를 만들어라,. 맴버 클래스에 인스턴스 가각이 바깥 인스턴스를 참조한다면 비정적으로, 
 그렇지 않다면 정적으로 만들자.중첩 클래스가 한 메소드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한곳이고
 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스로 만들고 아니면 지역 클래스로 만들자
 
 
 ### 아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라
 소스 파일 하나에는 반드시 톱 레벨의 클래스 (또는 인터페이스) 하나만 담자 이 규칙만 따른다면 컴파일러가 한 클래스에
 대한 정의를 여러개 만들어 내는 일은 사라지고, 소스 파일을 어떤 순서로 컴파일 하던 바이너리 파일이나 프로그램의 동작이
 달라지는 일은 결코 일어나지 않을 것이다.
 
 
 ## 5장 Generic
 
 제네릭은 JAVA 5에서 부터 사용할 수 있다. 제네릭이 지원되기 전까지는 컬랙션에서 객체를 꺼낼때마다 형변환을 해줘야 했다.
 그래서 엉뚱한 타입의 객체를 넣어주면 런타임에 형변환 오류가 나곤 했다. 반면 제네릭을 사용하면 컬랙션이 담을 수 있는 타입을 컴파일러에 알려주게 된다. 그래서 컴파일러는 알아서 형변환 코드를 추가할 수ㅡ 있게 되고,
 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단한다.
 
 ### 아이템 26. Row type은 사용하지 말라
 
 - 제네릭 클리스(인터페이스) : 클래스/인터페이스 선언에 타입 매개변수가 쓰이는 것
 
 -> ex) List[E]
 
 - 제네릭 타입 : 제네릭 클래스나 인터페이스를 통틀어 지칭하는말
 
 -> 가각의 제네럴 타입은 일련의 매개변수화 타입을 정의한다.
 
 - 로 타입 : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을때를 말한다.
 
 -> 로 타입을 사용하게 되면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.
 
 -> 또한 런타임에 예외가 발생할수 있다.

 -> 즉 제네릭이 도입되기 이전 코드와의 호환성을 위해서 제공될 뿐이다.
 
 
 ### 아이템 27. 비검사 경고를 제공하라
 제네릭을 사용하기 시작하면 수많은 컴파일러 경고를 보게 될것이다.
 
 -> ex) 비검사 형변환 경고, 비검사 메소드 호출 경고, 가변인수 타입 경고, 비검사 변환 경고 등 
 
 -> 할수 있는 한 모든 비검사 경고를 제거하는것이 좋다. (안정성 보장)
 
 -> 경고를 제거할 수는 없지만 타입이 안전하다고 확신을 할수 있다면 '@SuppressWarning("unchecked")'를 사용하자
 
 -> '@SuppressWarning("unchecked")'는 항상 가능한 좁은 범위에 적용해보자 (변수선언, 짧은 메소드, 생성자...)
 
 -> '@SuppressWarning("unchecked")'를 사용할 때에는 그 경고를 무시해도 되는 이유를 항상 주석으로 남겨놓아야 한다.
 
 
 ### 아이템 28. 배열 보다는 List를 사용하자.
 배열과 제네릭 타입에는 중요한 두가지 차이가 있다.
 
 - 배열은 공변(covariant; 共變)이다. 반면 제네릭은 불공변(incovariant; 不共變) 이다.
 
 - 배열은 실체화(reify)가 된다.
  
  -> 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인하다. Long 배열에 String을 넣으면 ArrayStoreException이 발생한다.
  
  -> 형 안정성을 보장 받지 못함
 
 - 제네릭은 타입 정보가 런타임에는 소거가 된다.
 
 ->  원소 타입을 컴파일 타임에만 검사하며 런타임에서는 알수도 없다.
 
 -> 소거는 제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘
 
 즉 이러한 이유 때문에 컴파일 오류나 경고를 만난다면 배열을 리스트로 대체하는 방법을 적요하자.
 
 
 ### 아이템 29. 이왕이면 제네릭 타입으로 만들라
 
 클라이언트에서 직접 형변환을 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다. 
 그러니 새로운 타입을 설계 할때는 형변환 없이도 사용할 수 있도록 해라, 그
 렇게 하려면 제네릭 타입으로 만들어야 하는 경우가 많다. 기존 클라이언트에서 영향을 주지 않으면서
 새로운 사용자를 훨씬 편하게 해주는 길이다.
 
 ### 아이템 30. 이왕이면 제네릭 메소드로 만들라
 
 제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환을 해야하는 메소드 보다
 제네릭 메소드가 더 안전하며 사용하기도 쉽다.
 타입과 마찬가지로 메소드도 형변환 없이 사용할 수 있는 편이 좋으며, 많은 경우 그렇게 하려면
 제네릭 메소드가 되어야 한다.
 
 ### 아이템 31. 한정적 와일드카드를 사용해 API 유연성을 높이라
 
 - 유연성을 극대화 하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하는 것이 좋다.
 
 - 단. 반환타입에는 한정적 와일드카드 타입을 사용하면 안된다.
 
 - 즉 조금 복잡하더라도 와일드카드 타입을 적용하면 API가 유연해지나 널리 쓰이는 라이브러리를 작성할 경우 와일드 카드를 적절하게 사용해야 한다
    
    -> PECS( 생산자[producer] 는 extends를 소비자[consumer]는 super를 사용한다.
    
 ### 아이템 32. 제네릭과 가변인수를 함께 쓸 때에는 신중하라
 
 - 가변인수: 필요에 따라 메게변수(인수)를 조절하는 기술
 
 - 가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고, 배열과 제네릭 타입 규칙이 서로 다름, 제네릭 varargs 매개변수는 타입 안전하지 않지만 허용된다.
 
 - 메소드에 제네릭(혹은 메게변수화된) varargs 매개변수를 사용하고자 한다면, 먼저 그 메소드가 타입이 안전한지 확인한 다음에 @SafeVarangs 어노테이션을 달아 사용하는데 불편함이 없게 하자
 
 
 ### 아이템 33. 타입 안전 이종 컨테이너를 고려하라
 
 -  컬랙션 API로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰수 있는 타입 매개변수의 수가 고정이 되어있다.
 
 - 그러나 컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 이런 제약 없는 타입 안전 이종 컨테이너를 만들수 있다. 타입 안전 이종 컨테이너는 class를 키로쓰며 이런식으로 쓰이는 class 객체를 타입 토큰이라고 한다.
 
 - 예) 데이터베이스 행을 표현한 DatabaseROw 타입에는 제네릭 타입인 Column[T]을 키로 쓸수 있다
 
## 6장 열거타입과 어노테이션
 
 JAVA에는 특수한 목적의 참조타입이 두가지 있다.
 
 - 열거 타입 (enum)
 
 - 어노테이션 (annotation)
 
 ### 아이템 34. int 상수 대신 열거 타입을 사용하라
 
 - 열거타입이 정수 상수보다 좋은점은 더 읽기 쉽고 안전하고 강력하다.
 
 - 대다수 열거 타입이 명시적 생성자나 메소드 없이 쓰이지만, 각 상수를 특정 데이터와 연결 짓거나 상수마다 다르게 동작할때는 필요하다.
 
 - 그물게는 하나의 메소드가 상수별로 다르게 동작해야 할때도 있는데 이때는 switch문 대신 상수별 메소드 구현을 사용하는 것이 좋다.
 
 - 열거타입 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 사용하자.
 
 ### 아이템 35. ordinal 메소드 대신 인스턴스 필드를 사용하자
 
 
 
 ### 아이템 36. 비트필드 대신 EnumSet을 사용하자
 
 - 열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다고 해도 비트 필드를 사용할 이유는 없다.
 
 - EnumSet 클래스가 비트 필드 수준의 명료함과 서능을 제공하고 열거타입의 장점까지 선사한다.
 
 - EnumSet의 유일한 단점은 (~ JAVA 11) 불변의 EnumSet을 만들수 없다.
 
 - 그때까지 명확성과 성능이 조금 희생되지만 Collections.unmodifiableSet으로 EnumSet을 감싸 사용할수 없다.
 
 ### 아이템 37. ordinal 인덱싱 대신 EnumMap을 사용하라
 
 - 배열의 인덱스를 얻기 위해 ordinal을 쓰는 것은 일반적으로 좋지 않으나, 대신 EnumMap을 사용하자
 
 - 다차원 관계는 EnumMap<... EnumMap<...>>으로 표현하라
 
 - 어플리케이션 프로그래머는 Enum.ordinal을 (웬만해서는) 사용하지 말아야 한다.
 
 ### 아이템 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라
 
 - 열거타입 자체는 확장할수 없으나, 인터페이스와 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은 효과를 나타 낼수 있다.
 
 - 이렇게 하게 되면 클라이언트는 이 인터페이스를 구현해 자신만의 열거 타입(또는 다른 타입)을 만들 수 있다. 
 
 - API가 인터페이스 기반으로 작성되었다면 기본 열거 타입과 인스턴스가 쓰이는 모든 곳은 새로 확장한 열거 타입의 인스턴스로 대체해 사용할수 있다.
 
 ### 아이템 39. 명령 패턴 보다 어노테이션을 이용하자
 
 ### 아이템 40. @Override 어노테이션을 일관대게 사용하자
 
 - 상위 클래스의 메소드를 재정의하려는 오든 메소드에 @Override 어노테이션을 달자 (예외 - 구체 클래스에서 상위 클래스의 추상 메소드를 쟈정의 할때)

### 아이템 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하자

마커 어노테이션이 등장하면서 마커 인터페이스는 구식이 되었다라는 이야기를 들은적이 있을것이다.
그러나 마커 인터페이스는 두가지 면에서 마커 어노테이션보다 낫다.

- 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸수 있으나, 마커 어노테이션은 어엿한 타입이기 때문에 그렇지 못하다.

- 적용 대상을 더 정밀하게 지정할수 있다.

- 반대로 마커 어노테이션이 마커 인터페이스보다 나은 점으로는 거대한 어노테이션 시스템의 지원을 받을수 있다.

 -> 마커 인터페이스와 마커 어노테이션은 각자의 쓰임이 있다.
 
 -> 새로 추가하는 메소드 없이 단지 타입의 정의가 목적이라면 마커 인터페이스를 사용하는 것이 좋다. 클래스나 인터페이스 외의 프로그램 요소에 마킹 해야 하거나, 어노테이션을 적극 활용하는 프레임워크의 일부로
 그 마커를 편입시키고자 한다면 마커 어노테이션이 좋다.
 
 ** 적용 대상이 ElementType.TYPE 인 마커 어노테이션을 작성하고 있다면, 잠시 여유를 가지고 마커 어노테이션 으로 구현하는게 옳은지, 혹은 마커 인터페이스가 낫지는 않을지 곰곰히 생각을 해봐야 한다. **
 
 
 ## 7장 람다와 스트림
 
 JAVA 8 에서는 함수형 인터페이스, 람다, 메소드 참조라는 개념이 추가되면서, 함수 객체를 더욱 쉽게 구현할수 있게 되었다.
 이와 함께 스트림 API까지 추가 되어 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원하기 시작하였다.
 
 ### 아이템 42. 익명 클래스 보다는 람다식을 사용하자
 
 - 타입을 명시해야 코드가 더 명확한 경우를 제외하고는, 람다의 모든 매개변수 타입을 생략하자
 
 -> ex) Collections.sort(words, comparingInt(String::length)); -> word.sort(coparingInt(String:length));
 
 - 람다식은 이름이 없고 문서화도 못 한다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다는 사용하지 말아야 한다.
 
 - 익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하는 것이 좋ㄱ다.
 
 ### 아이템 43/ 람다보다는 메소드 참조를 사용하자
 
 -> 메소드 참조는 람다의 간단 명료한 대안이 될수 있다. 메소드 참조 쪽이 짧고 명확하다면 메소드 참조를 쓰고, 그렇지 않을때만 람다를 사용하자
 
 ### 아이템 44. 표준 함수형 인터페이스를 사용하자
 
 - 필요한 용도에 맞는게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하는것이 좋다.
 
 - 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어서 사용하지는 말자 (계산량이 많을때에는 성능이 확 떨어짐)
 
 - 직접 만든 함수형 인터페이스에는 항상 @FuntionalInterface 어노테이션을 사용하자
 
 -> JAVA 8 버전 부터는 람다를 지원하기 때문에 API를 설계할 떄에 람다도 염두해야 한다.
 
 -> 인랴ㅕㄱ 값과 반환값에 함수형 인터페이스 타입을 활용하자
 
 -> 보통은 java.util.function 패키지의 표준 함수형 인터페이스를 사용하는것이 가장 좋은 선택이나 흔치 않치만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을때도 있음을 잊지 말자.
 
 ### 아이템 45. Stream은 주의해서 사용하자
  
  스트림 API는 다량의 데이터 처리 작업 (순차, 병렬)을 돕고자 JAVA 8에서 추가되었다.
  
  - 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다.
  
  - 스트림 파이프라인은 이 원소들로 수행하는 연산단계를 표현하는 개념이다.
  
  - 스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘다 해보고 좀더 나은 쪽을 택하라
  
  ### 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라
  
  - 스트림 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체에 있다.
  
  - 스트림뿐 아니라 스트림 관련 객체에서 건네지는 모든 함수 객체가 부작용이 없어야 한다.
  
  - 종단 연산 중 forEach는 스트림이 수행한 계산 결과를 보고 할때만 이용하고 계산 자체에는 이용하지 말자
  
  ### 아이템 47. 변환 타입으로는 스트림 보다 컬렉션이 좋다.
  
  - 원소 시퀀스를 반환하는 메소드를 작성할 때에는 이를 스트림으로 처리하기를 원하는 사용자와 반복으로 처리함을 원할수 잇는 사용자 둘다 떠울라야 한다.
  
  - 반환 전부터 이미 원소를 컬랙션에서 관리하고 있거나, 컬렉션을 하나 더 만들어도 될 정도로 적다면 ArrayList와 같은 표준 컬랙션에 담아서 관리해라
  
  - 컬랙션을 반환하는 것이 불가능 하다면 스트림과 Iterable중에서 좀더 나은 쪽을 택하라
  
  
  ### 아이템 48. 스트림 병렬화는 주의 해서 사용하자
  
  - 데이터 소스가 Stream.iterate거나 중간 연산으로 limit을 사용하면 파이프라인 병렬화로는 성능 개선을 기대할수 없다.
  
  - 대체로 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일때 병렬화의 효과가 가장 좋다.
  
  - 스트림의 잘못 병렬화를 하면 (응답 불가를 포함해) 성능이 나빠질뿐 아니라 결과 자체가 잘못되거나 예측 못하는 동작이 발생할수 있다.
  
  - 조건이 잘 갖춰지면 parlel 메소드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 만끽할수 있기 때문에 잘 써야 한다.
  
  ## 8장 메소드
  
  ### 아이템 49. 메게변수가 유효한지 검사해라
  
  메소드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 한다. 그 제약들을 문서화 하고 메소드 코드 시작 부분에서 명시적으로 검사해야한다.
  
### 아이템 50. 적시에 방어적 복사본을 만들라
  
- 클래스가 클라이언트로 부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소들은 반드시 방어적으로 복사해야한다.
  
- 만약 복사 비용이 너무 크거나 클라이언트가 그 요소들을 잘못 수정할일이 없음을 신뢰한다면 방어적 복사 대신 해당 구성요소를 수정했을때 책임이 클라이언트에 있음을 명시해야 한다.

### 아이템 51.메소드 시그니처를 신중하게 설계 해라
  
- 메소드의 이름을 신중하게 지어라
  
- 편의 메소드를 너무 많이 만들지 마라
  
- 매개변수 목록은 짧게 유지하자
  
- 같은 타입의 매개 변수 여러 개가 연달아 나오는 경우가 특히 해롭다.

- 매개변수의 타입으로는 클래스 보다는 인터페이스가 더 낫다.

- boolean 보다는 원소 2개짜리 열거 타입이 낫다. (메소드 이름상 boolean을 받아야 의미가 더 명확할때는 제외한다.)

### 아이템 52. 다중정의는 신중하게 사용해라

- 프로그래밍 언러가 다중정의를 허용한다고 해서 다중정의를 꼭 활용하라는 뜻은 아니다.

- 일반적으로 매개변수 수가 같을 때는 다중정의를 피하는 것이 좋다.

- 상황에 따라 특히 생성자라면 이 조언을 따르지 못할 것이다. 그러면 햇갈릴만한 매개변수는 형변환하여 정확한 다중정의 메소드가 선택되도록 해야 한다.
  이것이 불가능 하다면 (ex) 기존 클래스를 수정해 새로운 인터페이스를 구성해야 할때는 같은 객체를 입력받는 다중정의 메소드를이 모두 동일하게 동작하도록 만들어야 한다.

### 아이템 53. 가변인수는 신중하게 사용해라

- 인수 개수가 일저하지 않은 메소드를 정의해야 한다면 가변인수가 반드시 필요하다.

- 메소드를 정의 할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할때에는 성능 문제 까지 고려해야 한다.


### 아이템 54. null이 아닌, 빈 컬렉션 이나 배열을 반환해라

### 아이템 55. Optional 반환은 신중하게 해라

- 값을 반환하지 못할 가능성이 있고, 호출할 떄마다 반환값이 없을 가능성을 염두에 둬야 하는 메소드라면 Optional을 반환해야 할 상황일 수 있다.

- 하지만 Optional 반환에는 성능 저하가 뒤따르니, 성능에 민감한 메소드라면 null을 반환하거나 예외를 던지는 편이 나을수도 있다.

### 아이템 56. 공개된 API요소에는 항상 문서화 주석을 작성해라

- API를 올바르게 문서화하려면 공개된 모든 클래스,인터페이스,메소드,필드선언에 문서화 주석을 다는것이 좋다.

- 표준 규약을 일관되게 디티다

## 9장 일반적인 프로그래밍 원칙

### 아이템 57. 지역변수 범위를 최소화해라

- 지역변수의 범위를 줄이는 가장 강력한 기법은 역시 "가장 처음 쓰일 때 선언하기"다.

- 거의 모든 지역변수 선언과 동시에 초기화해야한다.

### 아이템 58. 전통적인 for문 보다는 for-each 문을 사용해라

- for-each : 향상된 for문 / 반복자와 인덱스 변수를 사용하지 않아 소스가 깔끔해진다. / 하나의 관용구로 컬렉션과 배열을 모두 처리할수 있다.

- for-each를 사용하지 말아야 하는경우

1. 파괴적인 필터링 - 컬렉션을 순회하면서 선택된 원소를 제거해야 한다변 반드시 remove 메소드를 호출해야 한다. java 8 부터는 Collection의 removeIF 메소드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.

2. 변형 - 리스트나 배열을 순회 하면서 그 원소의 값 일부 혹은 전체를 교체해야하는 경우 리스트의 반복자나 배열의 인덱스를 사용해야 한다.

3. 병렬 반복 - 여러 컬랙션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

### 아이템 59. 라이브러리를 익히고 사용해라

- 아주 특별한 나만의 기능이 아니라면 누군가 이미 라이브러리 형태로 구현해놨을 가능성이 크다.

- 공개된 라이브러리를 사용하는 것이 코드 품질과 안정성을 높읽수 있다.

### 아이템 60. 정확한 답이 필요하다면 float와 Double을 피하자

- 정확한 계산이 필요하다면 float나 double을 피하자

- 소수점 추적은 시스템 상에 맡기고, 코딩 시 불편함이나 성능저하를 신경쓰지 않겠다면 BigDecimal을 사용하자

### 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하자

- 기본형 : int, double, boolean <-> 박싱된 기본 타입 : Integer, Double, Boolean

- 기본형과 박싱된 기본형 타입의 차이

  - 첫번째: 기본형은 값만 가지고 있으나 박스된 기본형 타입은 값에 식별성이란 속성이 포함된다.

  - 두번째 : 기본형 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않는 NULL을 가질수 있다.

  - 세번째 : 기본형 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

-  박싱형 기본 타입은  기본형과 혼용하면 언박싱이 되고 그 과정에서 nullPointerException이 발생 할수 있다.

### 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피해라

- 문자열은 다른 값 타입, 열거 타입, 혼합 타입을 대신하기에 적합하지 않다.

- 문자열은 권한을 표현하기에 적합하지 않다.

- 더 적합한 데이터 타입이 있거나 새로이 작성할 수 있다면 문자열을 쓰고 싶은 유혹들을 뿌리쳐라

### 아이템 63. 문자열 연결은 느리니 주의해라

- 문자열 연결 연산자로 문자열 N개를 연결하는 시간은 n^2에 비례한다.

- 성능을 포기 하고 싶지 않다면 String 보다는 StringBuilder를 사용하는 것이 좋다. (StringBuildr.append 사용 추천)

### 아이템 64. 객체는 인터페이스를 사용해 참조해라

- 적합한 인터페이스가 있땀녀 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하는 것을 추천한다.

- 인터페이스를 타입으로 상요하는 습관을 길러두면 프로그램이 훨씬 유연해진다.

- 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.

- 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 (상위의) 클래스 타입으로 사용하자.

### 아이템 65. 리플렉션보다는 인터페이스를 사용하자

- 컴파일타임 검사가 주는 이점을 하나도 누릴수 없다.

- 리플렉션을 이용하면 코드가 지저분하고 장황해진다.

- 성능이 떨어진다.

- 리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할수 있다.

- 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자

### 아이템 66. 네이티브 메소드는 신중하게 사용하자

- 성능을 개선할 목적으로 네이티브 메소드를 사용하는 것은 거의 권장하지 않다. (java 3 이전 제외)

- 저수준의 자원이나 네이티브 라이브러리를 사용해야만 하는 경우는 어쩔수 없더라도 네이티브 코드는 최소한만 사용하고 철저하게 테스트하자.


### 아이템 67. 최적화는 신중히 하라

- 빠른 프로그램 보다는 좋은 프로그램을 작성하자.

- 성능을 제한하는 설계를 피하자.

- API를 설계할 때 성능에 주는 영향을 고려하자.

- 성능을 위해 API를 왜곡하는 것은 매우 안좋다.

- 어쩔수 없이 최적화는 하게 되는 경우는 각각의 최적화 시도 전후로 성능을 추천하자

### 아이템 68. 일반적으로 통용되는 명명 규칙을 따르자

- 표준 명명 규칙을 체화 해서 자연스럽게 베어 나오도록 하는 것이 좋다.


## 10장 예외

### 아이템 69. 예외는 진짜 예외 상황에서만 사용하자

- 예외는 오직 예외 상황에서만 사용하고 절대로 일상적인 제어 흐름용으로 쓰이면 안된다.

- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없어야 한다.

### 아이템 70. 복구 할수 있는 상황에서는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하자

- 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하자

- 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자

- 검사 예외도 아니고 런타임 예외도 아닌 throwable은 사용하지 말자

### 아이템 71. 필요 없는 검사 예외 사용을 피하자

- 꼭 필요한 곳에서만 사용한다면 검사 예외는 프로그램의 안정성을 높여 주지만, 남용하면 쓰기 고통스러운 API를 만든다.

- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지는것이 좋다.

- 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 Optional 반환해도 될지 고민하고 Optional만으로는 상황을 처리하기 충분한 정보를 제공 할수 없을때만 검사 예외로 던지자

### 아이템 72. 표준 예외를 사용하자

- Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자

- 사용법

  - IllegalArgumentException : 허용하지 않는 값이 인수로 건너젔을때 (null 은 nullPotinerExceotion)

  - IllegalStateException : 객체가 메소드를 수행하기에 적절하지 않는 상태 일때

  - NullPointerException : null을 허용하지 않는 메소드에 null을 건넸을때

  - IndexOutOfBoundsException : 인덱스가 범위를 넘어 섰을때

  - ConcurrentModificationException : 허용하지 않는 동시 수정이 발견됬을때

  - UnsupportOperationException : 호출한 메서드를 지원하지 않을때

- 상황에 부합한다면 항상 표준 예외를 재사용하는 것이 좋다.

### 아이템 73. 추상화 수준에 맞는 예외를 던지자

- 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야한다.

- 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하자 

- 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다 (아이템 75)

### 아이템 74. 메소드가 던지는 모든 예외를 문서화 하자

- 메소드가 던질 가능성이 있는 모든 예외를 문서화 해라

- 문서화엥는 javadoc의 @throws 태그를 사용하면 된다.

- 검사 예외만 메서드 선언의 throws 문에 일일이 선언하고, 비검사 예외는 메소드 선언에는 기입하지 맣ㄹ자

- 발생 가능한 예외를 문서로 남겨놓지 않으면 다른 사람이 그 클래스나 인터페이스를 효과적으로 사용하기 어렵거나 심지어 불가능할수 있다.

### 아이템 75. 예외의 상세 메세지에 실패 관련 정보를 담자

- 실패 순간을 포착하려면 발생한 예외에 관여한 모든 매개변수와 필값을 실패 메세지에 담아야 한다.

- 사후 분석을 위해 실패 순간의 상황을 정확하게 포착해 예외에 상세히 적는 것이 좋다. (추적할수 있는 정보 제외)

### 아이템 76. 가능한 한 실패 원자적으로 만들자

- 일반화해 이야기하면, 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다.

### 아이템 77. 예외를 무시하지 말자

- try-catch 문에서 catch블록을 비워두면 예외가 존재할 이유가 없어진다.

- 예외를 무시하기로 했다면 catch안에 그 이유를 주석으로 남겨놓고 예외 변수의 이름도 ignored로 바꿔놓도록 하자

## 11장 동시성

### 아이템 78. 공유 중인 가변 데이터는 읽기, 쓰기 모두 동기화에 사용하라

- 동기화는 베타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 있어서 꼭 필요하다.

- 여러 쓰레드가 가변데이터를 공유하고 있다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야 한다.

- 쓰기와 읽기 모두가 동기화하지 않으면 동기화가 보장되지 않는다.

### 아이템 79. 과도한 동기화는 피하자

- 응답 불가와 안전 실패를 피하려면 동기화 메소드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도해선 안된다.

- 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는것이 좋다.

- 합당한 이유가 있는 경우에만 내부에서 동기화를 하고, 동기화를 했는지 여부를 문서로 명확하게 밝히자 (아이템 82)

### 아이템 80. Thread 보다는 Executor, task, Stream 을 애용해라

- Executor 서비스의 주요 기능
  
  - 특정 task가 완료되기를 기다린다.

  - task 모음 중 아무것 하나 (invokeAny 메소드) 혹은 모든 task(invokeAll 메소드)가 완료 되길 기다린다.

  - 실행자 서비스가 종료 하기를 기다린다.(awaitTermination 메소드)

  - 완료된 task들의 결과를 차례대로 받는다 (ExecutorCompletionService)

  - task를 특정 시간에 혹은 주기적으로 실행하게 된다 (ScheduledThreadPoolExecutor 이용)

### 아이템 81. wait과 notify보다는 동시성 유틸리티를 사용해라

- wait과 notifiy는 올바르게 사용하기가 까다로우니 고수준 동시성 유틸리티를 사용하자

- java.util.concurrent의 고수준 유틸리티는 세 범주로 나눌 수 있다.

  - 실행자 프레임워크

  - 동시성 컬랙션 : List, Queue, Map과 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션이다.
                 : 동시성 컬랙션에서 동시성을 무력화하는것은 불가능 하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.

  - 동기화 장치

- ConcurrentHashMap

- 시간을 잴땐 System.currentTimeMillis 가 아닌 System.namoTime을 사용하자

- wait 메소드를 사용하게 되는 경우는 반드시 대기 반복문(wait loop) 관용구를 사용하라. 반복문 밖에서는 절대로 호출하지 말자.

### 아이템 82. 스레드 안정성 수준을 문서화 해라

- 메소드 선언에 synchronized 한정자를 선언할지는 구현이슈일 뿐 API에 속하지 않는다.

- 멀티스레드 환경에서도 API를 안전하게 사용하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 한다.

  - 불변 
  - 무조건적 스레드 안전 
  - 조건부 스레드 안전
  - 스레드 안전하지 않음
  - 스레드 적대적

### 아이템 83. 지연 초기화는 신중하게 하라

- 지연 초기화는 필드의 초기화 시점을 그 값이 처음 필요할떄까지 늦추는 기법이다.

- 지연 초기화가 초기화 순환성을 깨트릴 것 같으면 synchronized를 단 접근자를 사용하자.

- 성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 관용구를 사용하자.

- 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중검사 관용구를 사용하자.

### 아이템 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라

- 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.

- 스레드를 당장 처리헤야 할 작업이 없다면 실행되서는 안된다.

- Thread.yield와 스레드 우선순위는 절대로 의존해서는 안된다.

## 12장 직렬화

### 아이템 85. 자바 직렬화의 대안을 찾으라 : JSON, protocolBuf 

- 직렬화의 근본적인 문제는 공격범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점이다.

- 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는것이다.

- 특히 신뢰할 수 없는 데이터는 절대로 역직렬화를 하지 말아야 한다.

### 아이템 86. Serializable을 구현할지는 신중하게 결정하라

- Serializable을 구현하면 릴리스 한 뒤에는 수정하기 어렵다.

- 버그와 보안 구멍이 생길 위험성이 높아 진다. (아이템 85)

- 해당 클래스의 신버전을 릴리스 핳때 테스트 할 것이 늘어난다는 점이다.

- Serializable 구현 여부는 가볍게 결정할 사안이 아니다 (단. 객체를 전송하거나 저장할때 자바 직렬화를 이용하는 프레임워크용으로 만든 클라스라면 선택의 여지가 없다.)

- 상속용으로 설계된 클래스 (아이템 19)는 대부분 Serializable을 구현하면 안되며, 이넡페이스도 대부분 Serializable을 확장해선 안된다.

- 내부 클래스 (아아템 24)는 직렬화를 구현하면 안된다.

### 아이템 87. 커스텀 직렬화 형태를 고려해봐라

- 먼저 고민해보고 괜찮다고 판단될 떄만 기본 직렬화 형태를 사용하라.

- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.

- 기본 직렬화 형태가 적합하다고 결정 했ㄷ더라도 불변식 보장과 보안을 위해 readObject 메소드를 제공해야 할 때가 많다.

- 객체의 물리적 표현과 논리적 표현의 차이가 클때 기본 직렬화 형태를 사용하면 크게 네 가지 면에서 문제가 생긴다.

  - 공개 API가 현재의 내부 표현 방식에 영구적으로 묶인다.

  - 너무나 많은 공간을 차지 할수 있다.

  - 시간이 너무 많이 걸릴수 있다.

  - 스택 오버플로우를 일으킬수 있다.

- 해당 객체가 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야 한다.

- 객체의 전체 상태를 읽는 메소드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.

- 어떤 직렬화 형태를 택하든 직려로하 가능 클래스 모두에 직렬버전 UID를 명시적으로 사용하자.

- 구버전으로 직렬화된 인스턴스들과의 호환성을 끊을려는 경우를 제외하고 직렬버전 UID를 절대 수정하지 말아야 한다.

### 아이템 88. readObject 메서드는 방어적으로 작성하라

- readObjet 메소드를 작성할 떄에는 언제나 public 생성자를 작성하는 자세로 임해야 한다.

- readObject는 어떤 바이트 스트림이 넘어와더라도 유효한 인스턴스를 만들어 내야 한다.

  - private이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사해라. 불변 클래스 내의 가변 요소가 여기 속한다.

  - 모든 불변식을 검사하여 어긋나는 게 발견되면 InvalidObjectException을 던진다. 방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.

  - 역직렬화 후 객체 그래프 전체의 유효성을 검사해야한다면 ObjectInputValidation 인터페이스를 사용하라

  - 직접적이던 간접적이던, 재정의 할수 있는 메소드는 호출 하지 말자

### 아이템 89. 인스턴스 수를 통제해야 한다면 readResolve보다는 enum을 사용하자

- 불변식을 지키기 위해 인스턴스를 통제해야 한다면 가능한 한 열거 타입을 사용하는 것이 좋다.

- 여의치 않는 상황에서 직렬화와 인스턴스 통제가 모두 필요하다면 readResolve메소드를 넣어야 하고 그 클래스에서 모든 참조타입 인스턴스 필드를 transient으로 선언해야 한다.

#### 아이템 90. 직렬화된 인스턴스 대신에  직렬화 프록시를 사용하자.

- 제 3자가 확장할 수 없는 클래스라면 가능한 직렬화 프록시 패턴을 사용하자. 이 패턴이 아마도 중요한 불변식을 안정적으로 직렬화 해주는 가장 쉬운 방법이다.